<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dashboard - Control de Autos</title>
  <style>
    body { font-family: system-ui, Arial; margin: 20px; }
    .cards { display: grid; grid-template-columns: repeat(2, minmax(220px, 1fr)); gap: 12px; }
    .card { padding: 16px; border: 1px solid #ddd; border-radius: 12px; }
    .big { font-size: 42px; font-weight: 700; margin-top: 8px; }
    table { width: 100%; border-collapse: collapse; margin-top: 14px; }
    th, td { border-bottom: 1px solid #eee; padding: 10px; text-align: left; }
    .tag { display:inline-block; padding:4px 10px; border-radius: 999px; font-size: 12px; }
    .botado { background:#ffe5e5; }
    .permitido { background:#e6ffed; }
    .muted { color: #666; font-size: 13px; }

    .chart-wrap { margin-top: 10px; }
    .chart-controls { display:flex; gap:10px; align-items:center; margin-top:8px; flex-wrap:wrap; }
    .select, .btn { padding: 8px 10px; border:1px solid #ddd; border-radius: 10px; background:#fff; }
    .btn { cursor:pointer; }
    canvas { width: 100%; height: 190px; border: 1px solid #eee; border-radius: 12px; background:#fafafa; }
    .legend { font-size:12px; color:#444; margin-top:8px; }
  </style>
</head>
<body>
  <h1>Dashboard - Control de Autos</h1>
  <p class="muted">Se actualiza automáticamente cada 2 segundos.</p>

  <div class="cards">
    <div class="card">
      <div>Autos botados</div>
      <div class="big" id="botados">0</div>
      <div class="muted" id="lastUpdated"></div>
    </div>

    <div class="card">
      <div style="display:flex; align-items:baseline; justify-content:space-between; gap:12px;">
        <div>Historia de botados (línea)</div>
        <div class="muted">últimos 50 eventos</div>
      </div>

      <div class="chart-controls">
        <label class="muted" for="mode">Modo:</label>
        <select id="mode" class="select">
          <option value="cumulative" selected>Acumulado</option>
          <option value="perBucket">Por intervalo</option>
        </select>

        <label class="muted" for="bucket">Intervalo:</label>
        <select id="bucket" class="select">
          <option value="minute" selected>Minuto</option>
          <option value="hour">Hora</option>
          <option value="day">Día</option>
        </select>

        <button class="btn" id="redraw" type="button">Redibujar</button>
      </div>

      <div class="chart-wrap">
        <canvas id="chart" width="900" height="220"></canvas>
        <div class="legend" id="chartLegend"></div>
      </div>
    </div>
  </div>

  <h2>Últimos eventos</h2>
  <table>
    <thead>
      <tr>
        <th>Tipo</th>
        <th>Valor sensor</th>
        <th>Fecha y hora</th>
      </tr>
    </thead>
    <tbody id="events"></tbody>
  </table>

  <script>
    const modeSelect = document.getElementById("mode");
    const bucketSelect = document.getElementById("bucket");
    const redrawBtn = document.getElementById("redraw");

    redrawBtn.addEventListener("click", () => refresh());

    function pad2(n){ return String(n).padStart(2, "0"); }

    function parseDate(iso) {
      const d = new Date(iso);
      return isNaN(d.getTime()) ? null : d;
    }

    function bucketKey(d, mode) {
      const y = d.getFullYear();
      const m = pad2(d.getMonth() + 1);
      const day = pad2(d.getDate());
      const h = pad2(d.getHours());
      const min = pad2(d.getMinutes());

      if (mode === "day") return `${y}-${m}-${day}`;
      if (mode === "hour") return `${y}-${m}-${day} ${h}:00`;
      return `${y}-${m}-${day} ${h}:${min}`;
    }

    // Convierte eventos -> serie temporal
    function buildSeries(lastEvents, mode, bucketMode) {
      // Orden cronológico (API viene DESC)
      const events = [...lastEvents].reverse();

      // Solo botados, con timestamp válido
      const botados = events
        .filter(e => e.event_type === "botado")
        .map(e => ({ t: parseDate(e.created_at), raw: e }))
        .filter(e => e.t);

      if (botados.length === 0) return { points: [], labels: [] };

      if (mode === "cumulative") {
        // Un punto por botado: (tiempo, acumulado)
        let acc = 0;
        const points = botados.map(e => {
          acc += 1;
          return { t: e.t, y: acc };
        });
        return { points, labels: [] };
      }

      // perBucket: agrupar botados por minuto/hora/día
      const counts = new Map();
      const order = [];
      botados.forEach(e => {
        const key = bucketKey(e.t, bucketMode);
        if (!counts.has(key)) {
          counts.set(key, 0);
          order.push(key);
        }
        counts.set(key, counts.get(key) + 1);
      });

      // construir puntos “equiespaciados” (x = índice), con labels de tiempo
      const points = order.map((k, idx) => ({ x: idx, y: counts.get(k) || 0, label: k }));
      return { points, labels: order };
    }

    function drawLineChart(canvas, series, titleText) {
      const ctx = canvas.getContext("2d");

      // Ajuste retina / alta densidad
      const cssW = canvas.clientWidth || 900;
      const cssH = canvas.clientHeight || 220;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.round(cssW * dpr);
      canvas.height = Math.round(cssH * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      const W = cssW;
      const H = cssH;

      // Layout
      const padL = 44, padR = 16, padT = 16, padB = 28;
      const innerW = W - padL - padR;
      const innerH = H - padT - padB;

      // Clear
      ctx.clearRect(0, 0, W, H);

      // Fondo
      ctx.fillStyle = "#fafafa";
      ctx.fillRect(0, 0, W, H);

      // Si no hay datos
      if (!series || series.length === 0) {
        ctx.fillStyle = "#666";
        ctx.font = "13px system-ui, Arial";
        ctx.fillText("Sin datos de botados en los últimos eventos.", padL, padT + 20);
        return;
      }

      // Preparar x/y
      let xs = [];
      let ys = [];

      const isTimeSeries = series[0].t instanceof Date;

      if (isTimeSeries) {
        xs = series.map(p => p.t.getTime());
        ys = series.map(p => p.y);
      } else {
        xs = series.map(p => p.x);
        ys = series.map(p => p.y);
      }

      const xMin = Math.min(...xs), xMax = Math.max(...xs);
      const yMin = 0;
      const yMax = Math.max(1, Math.max(...ys));

      function xToPx(x) {
        const t = (xMax === xMin) ? 0.5 : (x - xMin) / (xMax - xMin);
        return padL + t * innerW;
      }
      function yToPx(y) {
        const t = (y - yMin) / (yMax - yMin);
        return padT + (1 - t) * innerH;
      }

      // Grid Y (4 líneas)
      ctx.strokeStyle = "#e9e9e9";
      ctx.lineWidth = 1;
      ctx.font = "11px system-ui, Arial";
      ctx.fillStyle = "#666";
      for (let i = 0; i <= 4; i++) {
        const yVal = Math.round((yMax * i) / 4);
        const y = yToPx(yVal);
        ctx.beginPath();
        ctx.moveTo(padL, y);
        ctx.lineTo(W - padR, y);
        ctx.stroke();
        ctx.fillText(String(yVal), 10, y + 4);
      }

      // Área bajo la curva (suave y simple)
      ctx.beginPath();
      series.forEach((p, i) => {
        const x = xToPx(isTimeSeries ? p.t.getTime() : p.x);
        const y = yToPx(p.y);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      // cerrar área
      ctx.lineTo(xToPx(isTimeSeries ? xs[xs.length - 1] : xs[xs.length - 1]), yToPx(0));
      ctx.lineTo(xToPx(isTimeSeries ? xs[0] : xs[0]), yToPx(0));
      ctx.closePath();
      ctx.fillStyle = "rgba(255, 209, 209, 0.9)";
      ctx.fill();

      // Línea
      ctx.beginPath();
      series.forEach((p, i) => {
        const x = xToPx(isTimeSeries ? p.t.getTime() : p.x);
        const y = yToPx(p.y);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.strokeStyle = "#c44";
      ctx.lineWidth = 2;
      ctx.stroke();

      // Puntos
      ctx.fillStyle = "#c44";
      series.forEach(p => {
        const x = xToPx(isTimeSeries ? p.t.getTime() : p.x);
        const y = yToPx(p.y);
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
      });

      // Etiquetas X (solo 2-3 para no saturar)
      ctx.fillStyle = "#666";
      ctx.font = "11px system-ui, Arial";

      if (isTimeSeries) {
        const first = series[0].t;
        const mid = series[Math.floor(series.length / 2)].t;
        const last = series[series.length - 1].t;

        const fmt = d => `${pad2(d.getHours())}:${pad2(d.getMinutes())}:${pad2(d.getSeconds())}`;
        const labels = [
          { t: first.getTime(), txt: fmt(first) },
          { t: mid.getTime(), txt: fmt(mid) },
          { t: last.getTime(), txt: fmt(last) },
        ];
        labels.forEach(l => {
          const x = xToPx(l.t);
          ctx.fillText(l.txt, Math.max(padL, Math.min(x - 22, W - padR - 50)), H - 10);
        });
      } else {
        // para buckets: usar primero/medio/último label
        const first = series[0].label || "";
        const mid = series[Math.floor(series.length / 2)].label || "";
        const last = series[series.length - 1].label || "";
        const labels = [
          { x: series[0].x, txt: first },
          { x: series[Math.floor(series.length / 2)].x, txt: mid },
          { x: series[series.length - 1].x, txt: last },
        ];
        labels.forEach(l => {
          const x = xToPx(l.x);
          ctx.fillText(l.txt, Math.max(padL, Math.min(x - 40, W - padR - 80)), H - 10);
        });
      }

      // Título
      ctx.fillStyle = "#333";
      ctx.font = "12px system-ui, Arial";
      ctx.fillText(titleText, padL, 12);
    }

    async function refresh() {
      const res = await fetch("/api/stats", { cache: "no-store" });
      const data = await res.json();

      document.getElementById("botados").textContent = data.botados;

      const now = new Date();
      document.getElementById("lastUpdated").textContent = `Actualizado: ${now.toLocaleString()}`;

      // tabla
      const tbody = document.getElementById("events");
      tbody.innerHTML = "";
      (data.last_events || []).forEach(ev => {
        const tr = document.createElement("tr");
        const tagClass = ev.event_type === "botado" ? "botado" : "permitido";
        tr.innerHTML = `
          <td><span class="tag ${tagClass}">${ev.event_type}</span></td>
          <td>${ev.sensor_value ?? ""}</td>
          <td>${ev.created_at}</td>
        `;
        tbody.appendChild(tr);
      });

      // gráfica historia
      const mode = modeSelect.value;       // cumulative / perBucket
      const bucketMode = bucketSelect.value; // minute / hour / day

      const { points } = buildSeries(data.last_events || [], mode, bucketMode);

      const canvas = document.getElementById("chart");
      const legend = document.getElementById("chartLegend");

      if (mode === "cumulative") {
        legend.textContent = "Botados acumulados a través del tiempo (con los últimos eventos disponibles).";
        drawLineChart(canvas, points, "Acumulado");
      } else {
        legend.textContent = `Botados por ${bucketMode} (con los últimos eventos disponibles).`;
        drawLineChart(canvas, points, `Por ${bucketMode}`);
      }
    }

    refresh();
    setInterval(refresh, 2000);

    // Redibuja al cambiar tamaño de ventana
    window.addEventListener("resize", () => refresh());
  </script>
</body>
</html>
